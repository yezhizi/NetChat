// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_messages_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_messages_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_messages_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_messages_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[22]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_messages_2eproto;
namespace netdesign2 {
class ChannelHeartRequest;
class ChannelHeartRequestDefaultTypeInternal;
extern ChannelHeartRequestDefaultTypeInternal _ChannelHeartRequest_default_instance_;
class ClientAckResponse;
class ClientAckResponseDefaultTypeInternal;
extern ClientAckResponseDefaultTypeInternal _ClientAckResponse_default_instance_;
class Contact;
class ContactDefaultTypeInternal;
extern ContactDefaultTypeInternal _Contact_default_instance_;
class ContactListRequest;
class ContactListRequestDefaultTypeInternal;
extern ContactListRequestDefaultTypeInternal _ContactListRequest_default_instance_;
class ContactMessageRequest;
class ContactMessageRequestDefaultTypeInternal;
extern ContactMessageRequestDefaultTypeInternal _ContactMessageRequest_default_instance_;
class ContactMessageResponse;
class ContactMessageResponseDefaultTypeInternal;
extern ContactMessageResponseDefaultTypeInternal _ContactMessageResponse_default_instance_;
class ContactRequest;
class ContactRequestDefaultTypeInternal;
extern ContactRequestDefaultTypeInternal _ContactRequest_default_instance_;
class FriendSendMessageRequest;
class FriendSendMessageRequestDefaultTypeInternal;
extern FriendSendMessageRequestDefaultTypeInternal _FriendSendMessageRequest_default_instance_;
class FriendSendMessageResponse;
class FriendSendMessageResponseDefaultTypeInternal;
extern FriendSendMessageResponseDefaultTypeInternal _FriendSendMessageResponse_default_instance_;
class LoginPreRequest;
class LoginPreRequestDefaultTypeInternal;
extern LoginPreRequestDefaultTypeInternal _LoginPreRequest_default_instance_;
class LoginPreResponse;
class LoginPreResponseDefaultTypeInternal;
extern LoginPreResponseDefaultTypeInternal _LoginPreResponse_default_instance_;
class LoginRequest;
class LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginResponse;
class LoginResponseDefaultTypeInternal;
extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class Message;
class MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class Packet;
class PacketDefaultTypeInternal;
extern PacketDefaultTypeInternal _Packet_default_instance_;
class RawMessage;
class RawMessageDefaultTypeInternal;
extern RawMessageDefaultTypeInternal _RawMessage_default_instance_;
class ServerAckResponse;
class ServerAckResponseDefaultTypeInternal;
extern ServerAckResponseDefaultTypeInternal _ServerAckResponse_default_instance_;
class ServerStatusRequest;
class ServerStatusRequestDefaultTypeInternal;
extern ServerStatusRequestDefaultTypeInternal _ServerStatusRequest_default_instance_;
class ServerStatusResponse;
class ServerStatusResponseDefaultTypeInternal;
extern ServerStatusResponseDefaultTypeInternal _ServerStatusResponse_default_instance_;
class ServerStatusUpdateRequest;
class ServerStatusUpdateRequestDefaultTypeInternal;
extern ServerStatusUpdateRequestDefaultTypeInternal _ServerStatusUpdateRequest_default_instance_;
class ServerStatusUpdateResponse;
class ServerStatusUpdateResponseDefaultTypeInternal;
extern ServerStatusUpdateResponseDefaultTypeInternal _ServerStatusUpdateResponse_default_instance_;
class SetupChannelRequest;
class SetupChannelRequestDefaultTypeInternal;
extern SetupChannelRequestDefaultTypeInternal _SetupChannelRequest_default_instance_;
}  // namespace netdesign2
PROTOBUF_NAMESPACE_OPEN
template<> ::netdesign2::ChannelHeartRequest* Arena::CreateMaybeMessage<::netdesign2::ChannelHeartRequest>(Arena*);
template<> ::netdesign2::ClientAckResponse* Arena::CreateMaybeMessage<::netdesign2::ClientAckResponse>(Arena*);
template<> ::netdesign2::Contact* Arena::CreateMaybeMessage<::netdesign2::Contact>(Arena*);
template<> ::netdesign2::ContactListRequest* Arena::CreateMaybeMessage<::netdesign2::ContactListRequest>(Arena*);
template<> ::netdesign2::ContactMessageRequest* Arena::CreateMaybeMessage<::netdesign2::ContactMessageRequest>(Arena*);
template<> ::netdesign2::ContactMessageResponse* Arena::CreateMaybeMessage<::netdesign2::ContactMessageResponse>(Arena*);
template<> ::netdesign2::ContactRequest* Arena::CreateMaybeMessage<::netdesign2::ContactRequest>(Arena*);
template<> ::netdesign2::FriendSendMessageRequest* Arena::CreateMaybeMessage<::netdesign2::FriendSendMessageRequest>(Arena*);
template<> ::netdesign2::FriendSendMessageResponse* Arena::CreateMaybeMessage<::netdesign2::FriendSendMessageResponse>(Arena*);
template<> ::netdesign2::LoginPreRequest* Arena::CreateMaybeMessage<::netdesign2::LoginPreRequest>(Arena*);
template<> ::netdesign2::LoginPreResponse* Arena::CreateMaybeMessage<::netdesign2::LoginPreResponse>(Arena*);
template<> ::netdesign2::LoginRequest* Arena::CreateMaybeMessage<::netdesign2::LoginRequest>(Arena*);
template<> ::netdesign2::LoginResponse* Arena::CreateMaybeMessage<::netdesign2::LoginResponse>(Arena*);
template<> ::netdesign2::Message* Arena::CreateMaybeMessage<::netdesign2::Message>(Arena*);
template<> ::netdesign2::Packet* Arena::CreateMaybeMessage<::netdesign2::Packet>(Arena*);
template<> ::netdesign2::RawMessage* Arena::CreateMaybeMessage<::netdesign2::RawMessage>(Arena*);
template<> ::netdesign2::ServerAckResponse* Arena::CreateMaybeMessage<::netdesign2::ServerAckResponse>(Arena*);
template<> ::netdesign2::ServerStatusRequest* Arena::CreateMaybeMessage<::netdesign2::ServerStatusRequest>(Arena*);
template<> ::netdesign2::ServerStatusResponse* Arena::CreateMaybeMessage<::netdesign2::ServerStatusResponse>(Arena*);
template<> ::netdesign2::ServerStatusUpdateRequest* Arena::CreateMaybeMessage<::netdesign2::ServerStatusUpdateRequest>(Arena*);
template<> ::netdesign2::ServerStatusUpdateResponse* Arena::CreateMaybeMessage<::netdesign2::ServerStatusUpdateResponse>(Arena*);
template<> ::netdesign2::SetupChannelRequest* Arena::CreateMaybeMessage<::netdesign2::SetupChannelRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace netdesign2 {

enum Contact_ContactType : int {
  Contact_ContactType_FRIEND = 0,
  Contact_ContactType_GROUP = 1,
  Contact_ContactType_MEMBER = 2,
  Contact_ContactType_Contact_ContactType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Contact_ContactType_Contact_ContactType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Contact_ContactType_IsValid(int value);
constexpr Contact_ContactType Contact_ContactType_ContactType_MIN = Contact_ContactType_FRIEND;
constexpr Contact_ContactType Contact_ContactType_ContactType_MAX = Contact_ContactType_MEMBER;
constexpr int Contact_ContactType_ContactType_ARRAYSIZE = Contact_ContactType_ContactType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Contact_ContactType_descriptor();
template<typename T>
inline const std::string& Contact_ContactType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Contact_ContactType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Contact_ContactType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Contact_ContactType_descriptor(), enum_t_value);
}
inline bool Contact_ContactType_Parse(
    const std::string& name, Contact_ContactType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Contact_ContactType>(
    Contact_ContactType_descriptor(), name, value);
}
enum MessageType : int {
  TEXT = 0,
  IMAGE = 1,
  FILE = 2,
  MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MessageType_IsValid(int value);
constexpr MessageType MessageType_MIN = TEXT;
constexpr MessageType MessageType_MAX = FILE;
constexpr int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageType_descriptor();
template<typename T>
inline const std::string& MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MessageType_descriptor(), enum_t_value);
}
inline bool MessageType_Parse(
    const std::string& name, MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
// ===================================================================

class Packet :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netdesign2.Packet) */ {
 public:
  Packet();
  virtual ~Packet();

  Packet(const Packet& from);
  Packet(Packet&& from) noexcept
    : Packet() {
    *this = ::std::move(from);
  }

  inline Packet& operator=(const Packet& from) {
    CopyFrom(from);
    return *this;
  }
  inline Packet& operator=(Packet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Packet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Packet* internal_default_instance() {
    return reinterpret_cast<const Packet*>(
               &_Packet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Packet& a, Packet& b) {
    a.Swap(&b);
  }
  inline void Swap(Packet* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Packet* New() const final {
    return CreateMaybeMessage<Packet>(nullptr);
  }

  Packet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Packet>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Packet& from);
  void MergeFrom(const Packet& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Packet* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netdesign2.Packet";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 2,
    kPacketIdFieldNumber = 1,
  };
  // .google.protobuf.Any content = 2;
  bool has_content() const;
  void clear_content();
  const PROTOBUF_NAMESPACE_ID::Any& content() const;
  PROTOBUF_NAMESPACE_ID::Any* release_content();
  PROTOBUF_NAMESPACE_ID::Any* mutable_content();
  void set_allocated_content(PROTOBUF_NAMESPACE_ID::Any* content);

  // int32 packetId = 1;
  void clear_packetid();
  ::PROTOBUF_NAMESPACE_ID::int32 packetid() const;
  void set_packetid(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:netdesign2.Packet)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  PROTOBUF_NAMESPACE_ID::Any* content_;
  ::PROTOBUF_NAMESPACE_ID::int32 packetid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ServerStatusRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netdesign2.ServerStatusRequest) */ {
 public:
  ServerStatusRequest();
  virtual ~ServerStatusRequest();

  ServerStatusRequest(const ServerStatusRequest& from);
  ServerStatusRequest(ServerStatusRequest&& from) noexcept
    : ServerStatusRequest() {
    *this = ::std::move(from);
  }

  inline ServerStatusRequest& operator=(const ServerStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerStatusRequest& operator=(ServerStatusRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerStatusRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerStatusRequest* internal_default_instance() {
    return reinterpret_cast<const ServerStatusRequest*>(
               &_ServerStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ServerStatusRequest& a, ServerStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerStatusRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerStatusRequest* New() const final {
    return CreateMaybeMessage<ServerStatusRequest>(nullptr);
  }

  ServerStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerStatusRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerStatusRequest& from);
  void MergeFrom(const ServerStatusRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerStatusRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netdesign2.ServerStatusRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientPublicKeyFieldNumber = 1,
  };
  // string clientPublicKey = 1;
  void clear_clientpublickey();
  const std::string& clientpublickey() const;
  void set_clientpublickey(const std::string& value);
  void set_clientpublickey(std::string&& value);
  void set_clientpublickey(const char* value);
  void set_clientpublickey(const char* value, size_t size);
  std::string* mutable_clientpublickey();
  std::string* release_clientpublickey();
  void set_allocated_clientpublickey(std::string* clientpublickey);

  // @@protoc_insertion_point(class_scope:netdesign2.ServerStatusRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientpublickey_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ServerStatusResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netdesign2.ServerStatusResponse) */ {
 public:
  ServerStatusResponse();
  virtual ~ServerStatusResponse();

  ServerStatusResponse(const ServerStatusResponse& from);
  ServerStatusResponse(ServerStatusResponse&& from) noexcept
    : ServerStatusResponse() {
    *this = ::std::move(from);
  }

  inline ServerStatusResponse& operator=(const ServerStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerStatusResponse& operator=(ServerStatusResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerStatusResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerStatusResponse* internal_default_instance() {
    return reinterpret_cast<const ServerStatusResponse*>(
               &_ServerStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ServerStatusResponse& a, ServerStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerStatusResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerStatusResponse* New() const final {
    return CreateMaybeMessage<ServerStatusResponse>(nullptr);
  }

  ServerStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerStatusResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerStatusResponse& from);
  void MergeFrom(const ServerStatusResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerStatusResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netdesign2.ServerStatusResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerPublicKeyFieldNumber = 3,
    kOnlineFieldNumber = 1,
    kRegistrableFieldNumber = 2,
  };
  // string serverPublicKey = 3;
  void clear_serverpublickey();
  const std::string& serverpublickey() const;
  void set_serverpublickey(const std::string& value);
  void set_serverpublickey(std::string&& value);
  void set_serverpublickey(const char* value);
  void set_serverpublickey(const char* value, size_t size);
  std::string* mutable_serverpublickey();
  std::string* release_serverpublickey();
  void set_allocated_serverpublickey(std::string* serverpublickey);

  // bool online = 1;
  void clear_online();
  bool online() const;
  void set_online(bool value);

  // bool registrable = 2;
  void clear_registrable();
  bool registrable() const;
  void set_registrable(bool value);

  // @@protoc_insertion_point(class_scope:netdesign2.ServerStatusResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serverpublickey_;
  bool online_;
  bool registrable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ServerStatusUpdateRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netdesign2.ServerStatusUpdateRequest) */ {
 public:
  ServerStatusUpdateRequest();
  virtual ~ServerStatusUpdateRequest();

  ServerStatusUpdateRequest(const ServerStatusUpdateRequest& from);
  ServerStatusUpdateRequest(ServerStatusUpdateRequest&& from) noexcept
    : ServerStatusUpdateRequest() {
    *this = ::std::move(from);
  }

  inline ServerStatusUpdateRequest& operator=(const ServerStatusUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerStatusUpdateRequest& operator=(ServerStatusUpdateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerStatusUpdateRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerStatusUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const ServerStatusUpdateRequest*>(
               &_ServerStatusUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ServerStatusUpdateRequest& a, ServerStatusUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerStatusUpdateRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerStatusUpdateRequest* New() const final {
    return CreateMaybeMessage<ServerStatusUpdateRequest>(nullptr);
  }

  ServerStatusUpdateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerStatusUpdateRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerStatusUpdateRequest& from);
  void MergeFrom(const ServerStatusUpdateRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerStatusUpdateRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netdesign2.ServerStatusUpdateRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:netdesign2.ServerStatusUpdateRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ServerStatusUpdateResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netdesign2.ServerStatusUpdateResponse) */ {
 public:
  ServerStatusUpdateResponse();
  virtual ~ServerStatusUpdateResponse();

  ServerStatusUpdateResponse(const ServerStatusUpdateResponse& from);
  ServerStatusUpdateResponse(ServerStatusUpdateResponse&& from) noexcept
    : ServerStatusUpdateResponse() {
    *this = ::std::move(from);
  }

  inline ServerStatusUpdateResponse& operator=(const ServerStatusUpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerStatusUpdateResponse& operator=(ServerStatusUpdateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerStatusUpdateResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerStatusUpdateResponse* internal_default_instance() {
    return reinterpret_cast<const ServerStatusUpdateResponse*>(
               &_ServerStatusUpdateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ServerStatusUpdateResponse& a, ServerStatusUpdateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerStatusUpdateResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerStatusUpdateResponse* New() const final {
    return CreateMaybeMessage<ServerStatusUpdateResponse>(nullptr);
  }

  ServerStatusUpdateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerStatusUpdateResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerStatusUpdateResponse& from);
  void MergeFrom(const ServerStatusUpdateResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerStatusUpdateResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netdesign2.ServerStatusUpdateResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOnlineFieldNumber = 1,
    kRegistrableFieldNumber = 2,
  };
  // bool online = 1;
  void clear_online();
  bool online() const;
  void set_online(bool value);

  // bool registrable = 2;
  void clear_registrable();
  bool registrable() const;
  void set_registrable(bool value);

  // @@protoc_insertion_point(class_scope:netdesign2.ServerStatusUpdateResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  bool online_;
  bool registrable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class LoginPreRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netdesign2.LoginPreRequest) */ {
 public:
  LoginPreRequest();
  virtual ~LoginPreRequest();

  LoginPreRequest(const LoginPreRequest& from);
  LoginPreRequest(LoginPreRequest&& from) noexcept
    : LoginPreRequest() {
    *this = ::std::move(from);
  }

  inline LoginPreRequest& operator=(const LoginPreRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginPreRequest& operator=(LoginPreRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoginPreRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginPreRequest* internal_default_instance() {
    return reinterpret_cast<const LoginPreRequest*>(
               &_LoginPreRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LoginPreRequest& a, LoginPreRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginPreRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoginPreRequest* New() const final {
    return CreateMaybeMessage<LoginPreRequest>(nullptr);
  }

  LoginPreRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoginPreRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoginPreRequest& from);
  void MergeFrom(const LoginPreRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginPreRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netdesign2.LoginPreRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);

  // @@protoc_insertion_point(class_scope:netdesign2.LoginPreRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class LoginPreResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netdesign2.LoginPreResponse) */ {
 public:
  LoginPreResponse();
  virtual ~LoginPreResponse();

  LoginPreResponse(const LoginPreResponse& from);
  LoginPreResponse(LoginPreResponse&& from) noexcept
    : LoginPreResponse() {
    *this = ::std::move(from);
  }

  inline LoginPreResponse& operator=(const LoginPreResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginPreResponse& operator=(LoginPreResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoginPreResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginPreResponse* internal_default_instance() {
    return reinterpret_cast<const LoginPreResponse*>(
               &_LoginPreResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LoginPreResponse& a, LoginPreResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginPreResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoginPreResponse* New() const final {
    return CreateMaybeMessage<LoginPreResponse>(nullptr);
  }

  LoginPreResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoginPreResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoginPreResponse& from);
  void MergeFrom(const LoginPreResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginPreResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netdesign2.LoginPreResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChallengeFieldNumber = 1,
  };
  // string challenge = 1;
  void clear_challenge();
  const std::string& challenge() const;
  void set_challenge(const std::string& value);
  void set_challenge(std::string&& value);
  void set_challenge(const char* value);
  void set_challenge(const char* value, size_t size);
  std::string* mutable_challenge();
  std::string* release_challenge();
  void set_allocated_challenge(std::string* challenge);

  // @@protoc_insertion_point(class_scope:netdesign2.LoginPreResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr challenge_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class LoginRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netdesign2.LoginRequest) */ {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoginRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoginRequest* New() const final {
    return CreateMaybeMessage<LoginRequest>(nullptr);
  }

  LoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netdesign2.LoginRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kHashPasswordFieldNumber = 2,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);

  // string hashPassword = 2;
  void clear_hashpassword();
  const std::string& hashpassword() const;
  void set_hashpassword(const std::string& value);
  void set_hashpassword(std::string&& value);
  void set_hashpassword(const char* value);
  void set_hashpassword(const char* value, size_t size);
  std::string* mutable_hashpassword();
  std::string* release_hashpassword();
  void set_allocated_hashpassword(std::string* hashpassword);

  // @@protoc_insertion_point(class_scope:netdesign2.LoginRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hashpassword_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class LoginResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netdesign2.LoginResponse) */ {
 public:
  LoginResponse();
  virtual ~LoginResponse();

  LoginResponse(const LoginResponse& from);
  LoginResponse(LoginResponse&& from) noexcept
    : LoginResponse() {
    *this = ::std::move(from);
  }

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResponse& operator=(LoginResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoginResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginResponse* internal_default_instance() {
    return reinterpret_cast<const LoginResponse*>(
               &_LoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LoginResponse& a, LoginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoginResponse* New() const final {
    return CreateMaybeMessage<LoginResponse>(nullptr);
  }

  LoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoginResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netdesign2.LoginResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 2,
    kLoginedFieldNumber = 1,
  };
  // string token = 2;
  void clear_token();
  const std::string& token() const;
  void set_token(const std::string& value);
  void set_token(std::string&& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  std::string* mutable_token();
  std::string* release_token();
  void set_allocated_token(std::string* token);

  // bool logined = 1;
  void clear_logined();
  bool logined() const;
  void set_logined(bool value);

  // @@protoc_insertion_point(class_scope:netdesign2.LoginResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  bool logined_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Contact :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netdesign2.Contact) */ {
 public:
  Contact();
  virtual ~Contact();

  Contact(const Contact& from);
  Contact(Contact&& from) noexcept
    : Contact() {
    *this = ::std::move(from);
  }

  inline Contact& operator=(const Contact& from) {
    CopyFrom(from);
    return *this;
  }
  inline Contact& operator=(Contact&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Contact& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Contact* internal_default_instance() {
    return reinterpret_cast<const Contact*>(
               &_Contact_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Contact& a, Contact& b) {
    a.Swap(&b);
  }
  inline void Swap(Contact* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Contact* New() const final {
    return CreateMaybeMessage<Contact>(nullptr);
  }

  Contact* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Contact>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Contact& from);
  void MergeFrom(const Contact& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Contact* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netdesign2.Contact";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Contact_ContactType ContactType;
  static constexpr ContactType FRIEND =
    Contact_ContactType_FRIEND;
  static constexpr ContactType GROUP =
    Contact_ContactType_GROUP;
  static constexpr ContactType MEMBER =
    Contact_ContactType_MEMBER;
  static inline bool ContactType_IsValid(int value) {
    return Contact_ContactType_IsValid(value);
  }
  static constexpr ContactType ContactType_MIN =
    Contact_ContactType_ContactType_MIN;
  static constexpr ContactType ContactType_MAX =
    Contact_ContactType_ContactType_MAX;
  static constexpr int ContactType_ARRAYSIZE =
    Contact_ContactType_ContactType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ContactType_descriptor() {
    return Contact_ContactType_descriptor();
  }
  template<typename T>
  static inline const std::string& ContactType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ContactType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ContactType_Name.");
    return Contact_ContactType_Name(enum_t_value);
  }
  static inline bool ContactType_Parse(const std::string& name,
      ContactType* value) {
    return Contact_ContactType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 5,
    kNameFieldNumber = 2,
    kIdFieldNumber = 1,
    kOnlineFieldNumber = 3,
    kTypeFieldNumber = 4,
    kHeaderFieldNumber = 6,
  };
  // repeated .netdesign2.Contact members = 5;
  int members_size() const;
  void clear_members();
  ::netdesign2::Contact* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::netdesign2::Contact >*
      mutable_members();
  const ::netdesign2::Contact& members(int index) const;
  ::netdesign2::Contact* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::netdesign2::Contact >&
      members() const;

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // bool online = 3;
  void clear_online();
  bool online() const;
  void set_online(bool value);

  // .netdesign2.Contact.ContactType type = 4;
  void clear_type();
  ::netdesign2::Contact_ContactType type() const;
  void set_type(::netdesign2::Contact_ContactType value);

  // int32 header = 6;
  void clear_header();
  ::PROTOBUF_NAMESPACE_ID::int32 header() const;
  void set_header(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:netdesign2.Contact)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::netdesign2::Contact > members_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  bool online_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::int32 header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ContactListRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netdesign2.ContactListRequest) */ {
 public:
  ContactListRequest();
  virtual ~ContactListRequest();

  ContactListRequest(const ContactListRequest& from);
  ContactListRequest(ContactListRequest&& from) noexcept
    : ContactListRequest() {
    *this = ::std::move(from);
  }

  inline ContactListRequest& operator=(const ContactListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContactListRequest& operator=(ContactListRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ContactListRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContactListRequest* internal_default_instance() {
    return reinterpret_cast<const ContactListRequest*>(
               &_ContactListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ContactListRequest& a, ContactListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ContactListRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ContactListRequest* New() const final {
    return CreateMaybeMessage<ContactListRequest>(nullptr);
  }

  ContactListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ContactListRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ContactListRequest& from);
  void MergeFrom(const ContactListRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContactListRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netdesign2.ContactListRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContactsFieldNumber = 1,
  };
  // repeated .netdesign2.Contact contacts = 1;
  int contacts_size() const;
  void clear_contacts();
  ::netdesign2::Contact* mutable_contacts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::netdesign2::Contact >*
      mutable_contacts();
  const ::netdesign2::Contact& contacts(int index) const;
  ::netdesign2::Contact* add_contacts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::netdesign2::Contact >&
      contacts() const;

  // @@protoc_insertion_point(class_scope:netdesign2.ContactListRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::netdesign2::Contact > contacts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ClientAckResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netdesign2.ClientAckResponse) */ {
 public:
  ClientAckResponse();
  virtual ~ClientAckResponse();

  ClientAckResponse(const ClientAckResponse& from);
  ClientAckResponse(ClientAckResponse&& from) noexcept
    : ClientAckResponse() {
    *this = ::std::move(from);
  }

  inline ClientAckResponse& operator=(const ClientAckResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientAckResponse& operator=(ClientAckResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientAckResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientAckResponse* internal_default_instance() {
    return reinterpret_cast<const ClientAckResponse*>(
               &_ClientAckResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ClientAckResponse& a, ClientAckResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientAckResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientAckResponse* New() const final {
    return CreateMaybeMessage<ClientAckResponse>(nullptr);
  }

  ClientAckResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientAckResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientAckResponse& from);
  void MergeFrom(const ClientAckResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientAckResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netdesign2.ClientAckResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:netdesign2.ClientAckResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ContactRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netdesign2.ContactRequest) */ {
 public:
  ContactRequest();
  virtual ~ContactRequest();

  ContactRequest(const ContactRequest& from);
  ContactRequest(ContactRequest&& from) noexcept
    : ContactRequest() {
    *this = ::std::move(from);
  }

  inline ContactRequest& operator=(const ContactRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContactRequest& operator=(ContactRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ContactRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContactRequest* internal_default_instance() {
    return reinterpret_cast<const ContactRequest*>(
               &_ContactRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ContactRequest& a, ContactRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ContactRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ContactRequest* New() const final {
    return CreateMaybeMessage<ContactRequest>(nullptr);
  }

  ContactRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ContactRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ContactRequest& from);
  void MergeFrom(const ContactRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContactRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netdesign2.ContactRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContactFieldNumber = 1,
    kDeleteFieldNumber = 2,
  };
  // .netdesign2.Contact contact = 1;
  bool has_contact() const;
  void clear_contact();
  const ::netdesign2::Contact& contact() const;
  ::netdesign2::Contact* release_contact();
  ::netdesign2::Contact* mutable_contact();
  void set_allocated_contact(::netdesign2::Contact* contact);

  // bool delete = 2;
  void clear_delete_();
  bool delete_() const;
  void set_delete_(bool value);

  // @@protoc_insertion_point(class_scope:netdesign2.ContactRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::netdesign2::Contact* contact_;
  bool delete__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ServerAckResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netdesign2.ServerAckResponse) */ {
 public:
  ServerAckResponse();
  virtual ~ServerAckResponse();

  ServerAckResponse(const ServerAckResponse& from);
  ServerAckResponse(ServerAckResponse&& from) noexcept
    : ServerAckResponse() {
    *this = ::std::move(from);
  }

  inline ServerAckResponse& operator=(const ServerAckResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerAckResponse& operator=(ServerAckResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerAckResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerAckResponse* internal_default_instance() {
    return reinterpret_cast<const ServerAckResponse*>(
               &_ServerAckResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ServerAckResponse& a, ServerAckResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerAckResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerAckResponse* New() const final {
    return CreateMaybeMessage<ServerAckResponse>(nullptr);
  }

  ServerAckResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerAckResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerAckResponse& from);
  void MergeFrom(const ServerAckResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerAckResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netdesign2.ServerAckResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:netdesign2.ServerAckResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class RawMessage :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netdesign2.RawMessage) */ {
 public:
  RawMessage();
  virtual ~RawMessage();

  RawMessage(const RawMessage& from);
  RawMessage(RawMessage&& from) noexcept
    : RawMessage() {
    *this = ::std::move(from);
  }

  inline RawMessage& operator=(const RawMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RawMessage& operator=(RawMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RawMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RawMessage* internal_default_instance() {
    return reinterpret_cast<const RawMessage*>(
               &_RawMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RawMessage& a, RawMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(RawMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RawMessage* New() const final {
    return CreateMaybeMessage<RawMessage>(nullptr);
  }

  RawMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RawMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RawMessage& from);
  void MergeFrom(const RawMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RawMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netdesign2.RawMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 4,
    kHashFieldNumber = 5,
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // string content = 4;
  void clear_content();
  const std::string& content() const;
  void set_content(const std::string& value);
  void set_content(std::string&& value);
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  std::string* mutable_content();
  std::string* release_content();
  void set_allocated_content(std::string* content);

  // string hash = 5;
  void clear_hash();
  const std::string& hash() const;
  void set_hash(const std::string& value);
  void set_hash(std::string&& value);
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  std::string* mutable_hash();
  std::string* release_hash();
  void set_allocated_hash(std::string* hash);

  // int32 from = 1;
  void clear_from();
  ::PROTOBUF_NAMESPACE_ID::int32 from() const;
  void set_from(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 to = 2;
  void clear_to();
  ::PROTOBUF_NAMESPACE_ID::int32 to() const;
  void set_to(::PROTOBUF_NAMESPACE_ID::int32 value);

  // .netdesign2.MessageType type = 3;
  void clear_type();
  ::netdesign2::MessageType type() const;
  void set_type(::netdesign2::MessageType value);

  // @@protoc_insertion_point(class_scope:netdesign2.RawMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  ::PROTOBUF_NAMESPACE_ID::int32 from_;
  ::PROTOBUF_NAMESPACE_ID::int32 to_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Message :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netdesign2.Message) */ {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Message* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Message* New() const final {
    return CreateMaybeMessage<Message>(nullptr);
  }

  Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netdesign2.Message";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kIdFieldNumber = 2,
    kTimestampFieldNumber = 3,
    kInternalIdFieldNumber = 4,
  };
  // .netdesign2.RawMessage message = 1;
  bool has_message() const;
  void clear_message();
  const ::netdesign2::RawMessage& message() const;
  ::netdesign2::RawMessage* release_message();
  ::netdesign2::RawMessage* mutable_message();
  void set_allocated_message(::netdesign2::RawMessage* message);

  // int32 id = 2;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 timestamp = 3;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int32 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 internalId = 4;
  void clear_internalid();
  ::PROTOBUF_NAMESPACE_ID::int32 internalid() const;
  void set_internalid(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:netdesign2.Message)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::netdesign2::RawMessage* message_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  ::PROTOBUF_NAMESPACE_ID::int32 timestamp_;
  ::PROTOBUF_NAMESPACE_ID::int32 internalid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ContactMessageRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netdesign2.ContactMessageRequest) */ {
 public:
  ContactMessageRequest();
  virtual ~ContactMessageRequest();

  ContactMessageRequest(const ContactMessageRequest& from);
  ContactMessageRequest(ContactMessageRequest&& from) noexcept
    : ContactMessageRequest() {
    *this = ::std::move(from);
  }

  inline ContactMessageRequest& operator=(const ContactMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContactMessageRequest& operator=(ContactMessageRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ContactMessageRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContactMessageRequest* internal_default_instance() {
    return reinterpret_cast<const ContactMessageRequest*>(
               &_ContactMessageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ContactMessageRequest& a, ContactMessageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ContactMessageRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ContactMessageRequest* New() const final {
    return CreateMaybeMessage<ContactMessageRequest>(nullptr);
  }

  ContactMessageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ContactMessageRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ContactMessageRequest& from);
  void MergeFrom(const ContactMessageRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContactMessageRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netdesign2.ContactMessageRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
    kIdFieldNumber = 2,
    kInternalIdFieldNumber = 3,
  };
  // string token = 1;
  void clear_token();
  const std::string& token() const;
  void set_token(const std::string& value);
  void set_token(std::string&& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  std::string* mutable_token();
  std::string* release_token();
  void set_allocated_token(std::string* token);

  // int32 id = 2;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 internalId = 3;
  void clear_internalid();
  ::PROTOBUF_NAMESPACE_ID::int32 internalid() const;
  void set_internalid(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:netdesign2.ContactMessageRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  ::PROTOBUF_NAMESPACE_ID::int32 internalid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ContactMessageResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netdesign2.ContactMessageResponse) */ {
 public:
  ContactMessageResponse();
  virtual ~ContactMessageResponse();

  ContactMessageResponse(const ContactMessageResponse& from);
  ContactMessageResponse(ContactMessageResponse&& from) noexcept
    : ContactMessageResponse() {
    *this = ::std::move(from);
  }

  inline ContactMessageResponse& operator=(const ContactMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContactMessageResponse& operator=(ContactMessageResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ContactMessageResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContactMessageResponse* internal_default_instance() {
    return reinterpret_cast<const ContactMessageResponse*>(
               &_ContactMessageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ContactMessageResponse& a, ContactMessageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ContactMessageResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ContactMessageResponse* New() const final {
    return CreateMaybeMessage<ContactMessageResponse>(nullptr);
  }

  ContactMessageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ContactMessageResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ContactMessageResponse& from);
  void MergeFrom(const ContactMessageResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContactMessageResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netdesign2.ContactMessageResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // .netdesign2.Message message = 1;
  bool has_message() const;
  void clear_message();
  const ::netdesign2::Message& message() const;
  ::netdesign2::Message* release_message();
  ::netdesign2::Message* mutable_message();
  void set_allocated_message(::netdesign2::Message* message);

  // @@protoc_insertion_point(class_scope:netdesign2.ContactMessageResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::netdesign2::Message* message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class FriendSendMessageRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netdesign2.FriendSendMessageRequest) */ {
 public:
  FriendSendMessageRequest();
  virtual ~FriendSendMessageRequest();

  FriendSendMessageRequest(const FriendSendMessageRequest& from);
  FriendSendMessageRequest(FriendSendMessageRequest&& from) noexcept
    : FriendSendMessageRequest() {
    *this = ::std::move(from);
  }

  inline FriendSendMessageRequest& operator=(const FriendSendMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FriendSendMessageRequest& operator=(FriendSendMessageRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FriendSendMessageRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FriendSendMessageRequest* internal_default_instance() {
    return reinterpret_cast<const FriendSendMessageRequest*>(
               &_FriendSendMessageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(FriendSendMessageRequest& a, FriendSendMessageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FriendSendMessageRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FriendSendMessageRequest* New() const final {
    return CreateMaybeMessage<FriendSendMessageRequest>(nullptr);
  }

  FriendSendMessageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FriendSendMessageRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FriendSendMessageRequest& from);
  void MergeFrom(const FriendSendMessageRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FriendSendMessageRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netdesign2.FriendSendMessageRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // .netdesign2.RawMessage message = 1;
  bool has_message() const;
  void clear_message();
  const ::netdesign2::RawMessage& message() const;
  ::netdesign2::RawMessage* release_message();
  ::netdesign2::RawMessage* mutable_message();
  void set_allocated_message(::netdesign2::RawMessage* message);

  // @@protoc_insertion_point(class_scope:netdesign2.FriendSendMessageRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::netdesign2::RawMessage* message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class FriendSendMessageResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netdesign2.FriendSendMessageResponse) */ {
 public:
  FriendSendMessageResponse();
  virtual ~FriendSendMessageResponse();

  FriendSendMessageResponse(const FriendSendMessageResponse& from);
  FriendSendMessageResponse(FriendSendMessageResponse&& from) noexcept
    : FriendSendMessageResponse() {
    *this = ::std::move(from);
  }

  inline FriendSendMessageResponse& operator=(const FriendSendMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FriendSendMessageResponse& operator=(FriendSendMessageResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FriendSendMessageResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FriendSendMessageResponse* internal_default_instance() {
    return reinterpret_cast<const FriendSendMessageResponse*>(
               &_FriendSendMessageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(FriendSendMessageResponse& a, FriendSendMessageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FriendSendMessageResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FriendSendMessageResponse* New() const final {
    return CreateMaybeMessage<FriendSendMessageResponse>(nullptr);
  }

  FriendSendMessageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FriendSendMessageResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FriendSendMessageResponse& from);
  void MergeFrom(const FriendSendMessageResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FriendSendMessageResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netdesign2.FriendSendMessageResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // .netdesign2.Message message = 1;
  bool has_message() const;
  void clear_message();
  const ::netdesign2::Message& message() const;
  ::netdesign2::Message* release_message();
  ::netdesign2::Message* mutable_message();
  void set_allocated_message(::netdesign2::Message* message);

  // @@protoc_insertion_point(class_scope:netdesign2.FriendSendMessageResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::netdesign2::Message* message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class SetupChannelRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netdesign2.SetupChannelRequest) */ {
 public:
  SetupChannelRequest();
  virtual ~SetupChannelRequest();

  SetupChannelRequest(const SetupChannelRequest& from);
  SetupChannelRequest(SetupChannelRequest&& from) noexcept
    : SetupChannelRequest() {
    *this = ::std::move(from);
  }

  inline SetupChannelRequest& operator=(const SetupChannelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetupChannelRequest& operator=(SetupChannelRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetupChannelRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetupChannelRequest* internal_default_instance() {
    return reinterpret_cast<const SetupChannelRequest*>(
               &_SetupChannelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SetupChannelRequest& a, SetupChannelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetupChannelRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetupChannelRequest* New() const final {
    return CreateMaybeMessage<SetupChannelRequest>(nullptr);
  }

  SetupChannelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetupChannelRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetupChannelRequest& from);
  void MergeFrom(const SetupChannelRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetupChannelRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netdesign2.SetupChannelRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
  };
  // string token = 1;
  void clear_token();
  const std::string& token() const;
  void set_token(const std::string& value);
  void set_token(std::string&& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  std::string* mutable_token();
  std::string* release_token();
  void set_allocated_token(std::string* token);

  // @@protoc_insertion_point(class_scope:netdesign2.SetupChannelRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ChannelHeartRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netdesign2.ChannelHeartRequest) */ {
 public:
  ChannelHeartRequest();
  virtual ~ChannelHeartRequest();

  ChannelHeartRequest(const ChannelHeartRequest& from);
  ChannelHeartRequest(ChannelHeartRequest&& from) noexcept
    : ChannelHeartRequest() {
    *this = ::std::move(from);
  }

  inline ChannelHeartRequest& operator=(const ChannelHeartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelHeartRequest& operator=(ChannelHeartRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChannelHeartRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelHeartRequest* internal_default_instance() {
    return reinterpret_cast<const ChannelHeartRequest*>(
               &_ChannelHeartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ChannelHeartRequest& a, ChannelHeartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelHeartRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChannelHeartRequest* New() const final {
    return CreateMaybeMessage<ChannelHeartRequest>(nullptr);
  }

  ChannelHeartRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChannelHeartRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChannelHeartRequest& from);
  void MergeFrom(const ChannelHeartRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelHeartRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netdesign2.ChannelHeartRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:netdesign2.ChannelHeartRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Packet

// int32 packetId = 1;
inline void Packet::clear_packetid() {
  packetid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Packet::packetid() const {
  // @@protoc_insertion_point(field_get:netdesign2.Packet.packetId)
  return packetid_;
}
inline void Packet::set_packetid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  packetid_ = value;
  // @@protoc_insertion_point(field_set:netdesign2.Packet.packetId)
}

// .google.protobuf.Any content = 2;
inline bool Packet::has_content() const {
  return this != internal_default_instance() && content_ != nullptr;
}
inline const PROTOBUF_NAMESPACE_ID::Any& Packet::content() const {
  const PROTOBUF_NAMESPACE_ID::Any* p = content_;
  // @@protoc_insertion_point(field_get:netdesign2.Packet.content)
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Any*>(
      &PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline PROTOBUF_NAMESPACE_ID::Any* Packet::release_content() {
  // @@protoc_insertion_point(field_release:netdesign2.Packet.content)
  
  PROTOBUF_NAMESPACE_ID::Any* temp = content_;
  content_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Any* Packet::mutable_content() {
  
  if (content_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Any>(GetArenaNoVirtual());
    content_ = p;
  }
  // @@protoc_insertion_point(field_mutable:netdesign2.Packet.content)
  return content_;
}
inline void Packet::set_allocated_content(PROTOBUF_NAMESPACE_ID::Any* content) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(content_);
  }
  if (content) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      content = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, content, submessage_arena);
    }
    
  } else {
    
  }
  content_ = content;
  // @@protoc_insertion_point(field_set_allocated:netdesign2.Packet.content)
}

// -------------------------------------------------------------------

// ServerStatusRequest

// string clientPublicKey = 1;
inline void ServerStatusRequest::clear_clientpublickey() {
  clientpublickey_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ServerStatusRequest::clientpublickey() const {
  // @@protoc_insertion_point(field_get:netdesign2.ServerStatusRequest.clientPublicKey)
  return clientpublickey_.GetNoArena();
}
inline void ServerStatusRequest::set_clientpublickey(const std::string& value) {
  
  clientpublickey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netdesign2.ServerStatusRequest.clientPublicKey)
}
inline void ServerStatusRequest::set_clientpublickey(std::string&& value) {
  
  clientpublickey_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netdesign2.ServerStatusRequest.clientPublicKey)
}
inline void ServerStatusRequest::set_clientpublickey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  clientpublickey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netdesign2.ServerStatusRequest.clientPublicKey)
}
inline void ServerStatusRequest::set_clientpublickey(const char* value, size_t size) {
  
  clientpublickey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netdesign2.ServerStatusRequest.clientPublicKey)
}
inline std::string* ServerStatusRequest::mutable_clientpublickey() {
  
  // @@protoc_insertion_point(field_mutable:netdesign2.ServerStatusRequest.clientPublicKey)
  return clientpublickey_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ServerStatusRequest::release_clientpublickey() {
  // @@protoc_insertion_point(field_release:netdesign2.ServerStatusRequest.clientPublicKey)
  
  return clientpublickey_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ServerStatusRequest::set_allocated_clientpublickey(std::string* clientpublickey) {
  if (clientpublickey != nullptr) {
    
  } else {
    
  }
  clientpublickey_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clientpublickey);
  // @@protoc_insertion_point(field_set_allocated:netdesign2.ServerStatusRequest.clientPublicKey)
}

// -------------------------------------------------------------------

// ServerStatusResponse

// bool online = 1;
inline void ServerStatusResponse::clear_online() {
  online_ = false;
}
inline bool ServerStatusResponse::online() const {
  // @@protoc_insertion_point(field_get:netdesign2.ServerStatusResponse.online)
  return online_;
}
inline void ServerStatusResponse::set_online(bool value) {
  
  online_ = value;
  // @@protoc_insertion_point(field_set:netdesign2.ServerStatusResponse.online)
}

// bool registrable = 2;
inline void ServerStatusResponse::clear_registrable() {
  registrable_ = false;
}
inline bool ServerStatusResponse::registrable() const {
  // @@protoc_insertion_point(field_get:netdesign2.ServerStatusResponse.registrable)
  return registrable_;
}
inline void ServerStatusResponse::set_registrable(bool value) {
  
  registrable_ = value;
  // @@protoc_insertion_point(field_set:netdesign2.ServerStatusResponse.registrable)
}

// string serverPublicKey = 3;
inline void ServerStatusResponse::clear_serverpublickey() {
  serverpublickey_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ServerStatusResponse::serverpublickey() const {
  // @@protoc_insertion_point(field_get:netdesign2.ServerStatusResponse.serverPublicKey)
  return serverpublickey_.GetNoArena();
}
inline void ServerStatusResponse::set_serverpublickey(const std::string& value) {
  
  serverpublickey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netdesign2.ServerStatusResponse.serverPublicKey)
}
inline void ServerStatusResponse::set_serverpublickey(std::string&& value) {
  
  serverpublickey_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netdesign2.ServerStatusResponse.serverPublicKey)
}
inline void ServerStatusResponse::set_serverpublickey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  serverpublickey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netdesign2.ServerStatusResponse.serverPublicKey)
}
inline void ServerStatusResponse::set_serverpublickey(const char* value, size_t size) {
  
  serverpublickey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netdesign2.ServerStatusResponse.serverPublicKey)
}
inline std::string* ServerStatusResponse::mutable_serverpublickey() {
  
  // @@protoc_insertion_point(field_mutable:netdesign2.ServerStatusResponse.serverPublicKey)
  return serverpublickey_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ServerStatusResponse::release_serverpublickey() {
  // @@protoc_insertion_point(field_release:netdesign2.ServerStatusResponse.serverPublicKey)
  
  return serverpublickey_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ServerStatusResponse::set_allocated_serverpublickey(std::string* serverpublickey) {
  if (serverpublickey != nullptr) {
    
  } else {
    
  }
  serverpublickey_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serverpublickey);
  // @@protoc_insertion_point(field_set_allocated:netdesign2.ServerStatusResponse.serverPublicKey)
}

// -------------------------------------------------------------------

// ServerStatusUpdateRequest

// -------------------------------------------------------------------

// ServerStatusUpdateResponse

// bool online = 1;
inline void ServerStatusUpdateResponse::clear_online() {
  online_ = false;
}
inline bool ServerStatusUpdateResponse::online() const {
  // @@protoc_insertion_point(field_get:netdesign2.ServerStatusUpdateResponse.online)
  return online_;
}
inline void ServerStatusUpdateResponse::set_online(bool value) {
  
  online_ = value;
  // @@protoc_insertion_point(field_set:netdesign2.ServerStatusUpdateResponse.online)
}

// bool registrable = 2;
inline void ServerStatusUpdateResponse::clear_registrable() {
  registrable_ = false;
}
inline bool ServerStatusUpdateResponse::registrable() const {
  // @@protoc_insertion_point(field_get:netdesign2.ServerStatusUpdateResponse.registrable)
  return registrable_;
}
inline void ServerStatusUpdateResponse::set_registrable(bool value) {
  
  registrable_ = value;
  // @@protoc_insertion_point(field_set:netdesign2.ServerStatusUpdateResponse.registrable)
}

// -------------------------------------------------------------------

// LoginPreRequest

// string username = 1;
inline void LoginPreRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LoginPreRequest::username() const {
  // @@protoc_insertion_point(field_get:netdesign2.LoginPreRequest.username)
  return username_.GetNoArena();
}
inline void LoginPreRequest::set_username(const std::string& value) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netdesign2.LoginPreRequest.username)
}
inline void LoginPreRequest::set_username(std::string&& value) {
  
  username_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netdesign2.LoginPreRequest.username)
}
inline void LoginPreRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netdesign2.LoginPreRequest.username)
}
inline void LoginPreRequest::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netdesign2.LoginPreRequest.username)
}
inline std::string* LoginPreRequest::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:netdesign2.LoginPreRequest.username)
  return username_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoginPreRequest::release_username() {
  // @@protoc_insertion_point(field_release:netdesign2.LoginPreRequest.username)
  
  return username_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoginPreRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:netdesign2.LoginPreRequest.username)
}

// -------------------------------------------------------------------

// LoginPreResponse

// string challenge = 1;
inline void LoginPreResponse::clear_challenge() {
  challenge_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LoginPreResponse::challenge() const {
  // @@protoc_insertion_point(field_get:netdesign2.LoginPreResponse.challenge)
  return challenge_.GetNoArena();
}
inline void LoginPreResponse::set_challenge(const std::string& value) {
  
  challenge_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netdesign2.LoginPreResponse.challenge)
}
inline void LoginPreResponse::set_challenge(std::string&& value) {
  
  challenge_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netdesign2.LoginPreResponse.challenge)
}
inline void LoginPreResponse::set_challenge(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  challenge_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netdesign2.LoginPreResponse.challenge)
}
inline void LoginPreResponse::set_challenge(const char* value, size_t size) {
  
  challenge_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netdesign2.LoginPreResponse.challenge)
}
inline std::string* LoginPreResponse::mutable_challenge() {
  
  // @@protoc_insertion_point(field_mutable:netdesign2.LoginPreResponse.challenge)
  return challenge_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoginPreResponse::release_challenge() {
  // @@protoc_insertion_point(field_release:netdesign2.LoginPreResponse.challenge)
  
  return challenge_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoginPreResponse::set_allocated_challenge(std::string* challenge) {
  if (challenge != nullptr) {
    
  } else {
    
  }
  challenge_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), challenge);
  // @@protoc_insertion_point(field_set_allocated:netdesign2.LoginPreResponse.challenge)
}

// -------------------------------------------------------------------

// LoginRequest

// string username = 1;
inline void LoginRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LoginRequest::username() const {
  // @@protoc_insertion_point(field_get:netdesign2.LoginRequest.username)
  return username_.GetNoArena();
}
inline void LoginRequest::set_username(const std::string& value) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netdesign2.LoginRequest.username)
}
inline void LoginRequest::set_username(std::string&& value) {
  
  username_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netdesign2.LoginRequest.username)
}
inline void LoginRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netdesign2.LoginRequest.username)
}
inline void LoginRequest::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netdesign2.LoginRequest.username)
}
inline std::string* LoginRequest::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:netdesign2.LoginRequest.username)
  return username_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoginRequest::release_username() {
  // @@protoc_insertion_point(field_release:netdesign2.LoginRequest.username)
  
  return username_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:netdesign2.LoginRequest.username)
}

// string hashPassword = 2;
inline void LoginRequest::clear_hashpassword() {
  hashpassword_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LoginRequest::hashpassword() const {
  // @@protoc_insertion_point(field_get:netdesign2.LoginRequest.hashPassword)
  return hashpassword_.GetNoArena();
}
inline void LoginRequest::set_hashpassword(const std::string& value) {
  
  hashpassword_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netdesign2.LoginRequest.hashPassword)
}
inline void LoginRequest::set_hashpassword(std::string&& value) {
  
  hashpassword_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netdesign2.LoginRequest.hashPassword)
}
inline void LoginRequest::set_hashpassword(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hashpassword_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netdesign2.LoginRequest.hashPassword)
}
inline void LoginRequest::set_hashpassword(const char* value, size_t size) {
  
  hashpassword_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netdesign2.LoginRequest.hashPassword)
}
inline std::string* LoginRequest::mutable_hashpassword() {
  
  // @@protoc_insertion_point(field_mutable:netdesign2.LoginRequest.hashPassword)
  return hashpassword_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoginRequest::release_hashpassword() {
  // @@protoc_insertion_point(field_release:netdesign2.LoginRequest.hashPassword)
  
  return hashpassword_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_hashpassword(std::string* hashpassword) {
  if (hashpassword != nullptr) {
    
  } else {
    
  }
  hashpassword_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hashpassword);
  // @@protoc_insertion_point(field_set_allocated:netdesign2.LoginRequest.hashPassword)
}

// -------------------------------------------------------------------

// LoginResponse

// bool logined = 1;
inline void LoginResponse::clear_logined() {
  logined_ = false;
}
inline bool LoginResponse::logined() const {
  // @@protoc_insertion_point(field_get:netdesign2.LoginResponse.logined)
  return logined_;
}
inline void LoginResponse::set_logined(bool value) {
  
  logined_ = value;
  // @@protoc_insertion_point(field_set:netdesign2.LoginResponse.logined)
}

// string token = 2;
inline void LoginResponse::clear_token() {
  token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LoginResponse::token() const {
  // @@protoc_insertion_point(field_get:netdesign2.LoginResponse.token)
  return token_.GetNoArena();
}
inline void LoginResponse::set_token(const std::string& value) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netdesign2.LoginResponse.token)
}
inline void LoginResponse::set_token(std::string&& value) {
  
  token_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netdesign2.LoginResponse.token)
}
inline void LoginResponse::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netdesign2.LoginResponse.token)
}
inline void LoginResponse::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netdesign2.LoginResponse.token)
}
inline std::string* LoginResponse::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:netdesign2.LoginResponse.token)
  return token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoginResponse::release_token() {
  // @@protoc_insertion_point(field_release:netdesign2.LoginResponse.token)
  
  return token_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoginResponse::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:netdesign2.LoginResponse.token)
}

// -------------------------------------------------------------------

// Contact

// int32 id = 1;
inline void Contact::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Contact::id() const {
  // @@protoc_insertion_point(field_get:netdesign2.Contact.id)
  return id_;
}
inline void Contact::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:netdesign2.Contact.id)
}

// string name = 2;
inline void Contact::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Contact::name() const {
  // @@protoc_insertion_point(field_get:netdesign2.Contact.name)
  return name_.GetNoArena();
}
inline void Contact::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netdesign2.Contact.name)
}
inline void Contact::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netdesign2.Contact.name)
}
inline void Contact::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netdesign2.Contact.name)
}
inline void Contact::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netdesign2.Contact.name)
}
inline std::string* Contact::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:netdesign2.Contact.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Contact::release_name() {
  // @@protoc_insertion_point(field_release:netdesign2.Contact.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Contact::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:netdesign2.Contact.name)
}

// bool online = 3;
inline void Contact::clear_online() {
  online_ = false;
}
inline bool Contact::online() const {
  // @@protoc_insertion_point(field_get:netdesign2.Contact.online)
  return online_;
}
inline void Contact::set_online(bool value) {
  
  online_ = value;
  // @@protoc_insertion_point(field_set:netdesign2.Contact.online)
}

// .netdesign2.Contact.ContactType type = 4;
inline void Contact::clear_type() {
  type_ = 0;
}
inline ::netdesign2::Contact_ContactType Contact::type() const {
  // @@protoc_insertion_point(field_get:netdesign2.Contact.type)
  return static_cast< ::netdesign2::Contact_ContactType >(type_);
}
inline void Contact::set_type(::netdesign2::Contact_ContactType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:netdesign2.Contact.type)
}

// repeated .netdesign2.Contact members = 5;
inline int Contact::members_size() const {
  return members_.size();
}
inline void Contact::clear_members() {
  members_.Clear();
}
inline ::netdesign2::Contact* Contact::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:netdesign2.Contact.members)
  return members_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::netdesign2::Contact >*
Contact::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:netdesign2.Contact.members)
  return &members_;
}
inline const ::netdesign2::Contact& Contact::members(int index) const {
  // @@protoc_insertion_point(field_get:netdesign2.Contact.members)
  return members_.Get(index);
}
inline ::netdesign2::Contact* Contact::add_members() {
  // @@protoc_insertion_point(field_add:netdesign2.Contact.members)
  return members_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::netdesign2::Contact >&
Contact::members() const {
  // @@protoc_insertion_point(field_list:netdesign2.Contact.members)
  return members_;
}

// int32 header = 6;
inline void Contact::clear_header() {
  header_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Contact::header() const {
  // @@protoc_insertion_point(field_get:netdesign2.Contact.header)
  return header_;
}
inline void Contact::set_header(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  header_ = value;
  // @@protoc_insertion_point(field_set:netdesign2.Contact.header)
}

// -------------------------------------------------------------------

// ContactListRequest

// repeated .netdesign2.Contact contacts = 1;
inline int ContactListRequest::contacts_size() const {
  return contacts_.size();
}
inline void ContactListRequest::clear_contacts() {
  contacts_.Clear();
}
inline ::netdesign2::Contact* ContactListRequest::mutable_contacts(int index) {
  // @@protoc_insertion_point(field_mutable:netdesign2.ContactListRequest.contacts)
  return contacts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::netdesign2::Contact >*
ContactListRequest::mutable_contacts() {
  // @@protoc_insertion_point(field_mutable_list:netdesign2.ContactListRequest.contacts)
  return &contacts_;
}
inline const ::netdesign2::Contact& ContactListRequest::contacts(int index) const {
  // @@protoc_insertion_point(field_get:netdesign2.ContactListRequest.contacts)
  return contacts_.Get(index);
}
inline ::netdesign2::Contact* ContactListRequest::add_contacts() {
  // @@protoc_insertion_point(field_add:netdesign2.ContactListRequest.contacts)
  return contacts_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::netdesign2::Contact >&
ContactListRequest::contacts() const {
  // @@protoc_insertion_point(field_list:netdesign2.ContactListRequest.contacts)
  return contacts_;
}

// -------------------------------------------------------------------

// ClientAckResponse

// -------------------------------------------------------------------

// ContactRequest

// .netdesign2.Contact contact = 1;
inline bool ContactRequest::has_contact() const {
  return this != internal_default_instance() && contact_ != nullptr;
}
inline void ContactRequest::clear_contact() {
  if (GetArenaNoVirtual() == nullptr && contact_ != nullptr) {
    delete contact_;
  }
  contact_ = nullptr;
}
inline const ::netdesign2::Contact& ContactRequest::contact() const {
  const ::netdesign2::Contact* p = contact_;
  // @@protoc_insertion_point(field_get:netdesign2.ContactRequest.contact)
  return p != nullptr ? *p : *reinterpret_cast<const ::netdesign2::Contact*>(
      &::netdesign2::_Contact_default_instance_);
}
inline ::netdesign2::Contact* ContactRequest::release_contact() {
  // @@protoc_insertion_point(field_release:netdesign2.ContactRequest.contact)
  
  ::netdesign2::Contact* temp = contact_;
  contact_ = nullptr;
  return temp;
}
inline ::netdesign2::Contact* ContactRequest::mutable_contact() {
  
  if (contact_ == nullptr) {
    auto* p = CreateMaybeMessage<::netdesign2::Contact>(GetArenaNoVirtual());
    contact_ = p;
  }
  // @@protoc_insertion_point(field_mutable:netdesign2.ContactRequest.contact)
  return contact_;
}
inline void ContactRequest::set_allocated_contact(::netdesign2::Contact* contact) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete contact_;
  }
  if (contact) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      contact = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contact, submessage_arena);
    }
    
  } else {
    
  }
  contact_ = contact;
  // @@protoc_insertion_point(field_set_allocated:netdesign2.ContactRequest.contact)
}

// bool delete = 2;
inline void ContactRequest::clear_delete_() {
  delete__ = false;
}
inline bool ContactRequest::delete_() const {
  // @@protoc_insertion_point(field_get:netdesign2.ContactRequest.delete)
  return delete__;
}
inline void ContactRequest::set_delete_(bool value) {
  
  delete__ = value;
  // @@protoc_insertion_point(field_set:netdesign2.ContactRequest.delete)
}

// -------------------------------------------------------------------

// ServerAckResponse

// -------------------------------------------------------------------

// RawMessage

// int32 from = 1;
inline void RawMessage::clear_from() {
  from_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RawMessage::from() const {
  // @@protoc_insertion_point(field_get:netdesign2.RawMessage.from)
  return from_;
}
inline void RawMessage::set_from(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  from_ = value;
  // @@protoc_insertion_point(field_set:netdesign2.RawMessage.from)
}

// int32 to = 2;
inline void RawMessage::clear_to() {
  to_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RawMessage::to() const {
  // @@protoc_insertion_point(field_get:netdesign2.RawMessage.to)
  return to_;
}
inline void RawMessage::set_to(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  to_ = value;
  // @@protoc_insertion_point(field_set:netdesign2.RawMessage.to)
}

// .netdesign2.MessageType type = 3;
inline void RawMessage::clear_type() {
  type_ = 0;
}
inline ::netdesign2::MessageType RawMessage::type() const {
  // @@protoc_insertion_point(field_get:netdesign2.RawMessage.type)
  return static_cast< ::netdesign2::MessageType >(type_);
}
inline void RawMessage::set_type(::netdesign2::MessageType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:netdesign2.RawMessage.type)
}

// string content = 4;
inline void RawMessage::clear_content() {
  content_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& RawMessage::content() const {
  // @@protoc_insertion_point(field_get:netdesign2.RawMessage.content)
  return content_.GetNoArena();
}
inline void RawMessage::set_content(const std::string& value) {
  
  content_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netdesign2.RawMessage.content)
}
inline void RawMessage::set_content(std::string&& value) {
  
  content_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netdesign2.RawMessage.content)
}
inline void RawMessage::set_content(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  content_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netdesign2.RawMessage.content)
}
inline void RawMessage::set_content(const char* value, size_t size) {
  
  content_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netdesign2.RawMessage.content)
}
inline std::string* RawMessage::mutable_content() {
  
  // @@protoc_insertion_point(field_mutable:netdesign2.RawMessage.content)
  return content_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RawMessage::release_content() {
  // @@protoc_insertion_point(field_release:netdesign2.RawMessage.content)
  
  return content_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RawMessage::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  content_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:netdesign2.RawMessage.content)
}

// string hash = 5;
inline void RawMessage::clear_hash() {
  hash_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& RawMessage::hash() const {
  // @@protoc_insertion_point(field_get:netdesign2.RawMessage.hash)
  return hash_.GetNoArena();
}
inline void RawMessage::set_hash(const std::string& value) {
  
  hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netdesign2.RawMessage.hash)
}
inline void RawMessage::set_hash(std::string&& value) {
  
  hash_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netdesign2.RawMessage.hash)
}
inline void RawMessage::set_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netdesign2.RawMessage.hash)
}
inline void RawMessage::set_hash(const char* value, size_t size) {
  
  hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netdesign2.RawMessage.hash)
}
inline std::string* RawMessage::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:netdesign2.RawMessage.hash)
  return hash_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RawMessage::release_hash() {
  // @@protoc_insertion_point(field_release:netdesign2.RawMessage.hash)
  
  return hash_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RawMessage::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:netdesign2.RawMessage.hash)
}

// -------------------------------------------------------------------

// Message

// .netdesign2.RawMessage message = 1;
inline bool Message::has_message() const {
  return this != internal_default_instance() && message_ != nullptr;
}
inline void Message::clear_message() {
  if (GetArenaNoVirtual() == nullptr && message_ != nullptr) {
    delete message_;
  }
  message_ = nullptr;
}
inline const ::netdesign2::RawMessage& Message::message() const {
  const ::netdesign2::RawMessage* p = message_;
  // @@protoc_insertion_point(field_get:netdesign2.Message.message)
  return p != nullptr ? *p : *reinterpret_cast<const ::netdesign2::RawMessage*>(
      &::netdesign2::_RawMessage_default_instance_);
}
inline ::netdesign2::RawMessage* Message::release_message() {
  // @@protoc_insertion_point(field_release:netdesign2.Message.message)
  
  ::netdesign2::RawMessage* temp = message_;
  message_ = nullptr;
  return temp;
}
inline ::netdesign2::RawMessage* Message::mutable_message() {
  
  if (message_ == nullptr) {
    auto* p = CreateMaybeMessage<::netdesign2::RawMessage>(GetArenaNoVirtual());
    message_ = p;
  }
  // @@protoc_insertion_point(field_mutable:netdesign2.Message.message)
  return message_;
}
inline void Message::set_allocated_message(::netdesign2::RawMessage* message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete message_;
  }
  if (message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    
  } else {
    
  }
  message_ = message;
  // @@protoc_insertion_point(field_set_allocated:netdesign2.Message.message)
}

// int32 id = 2;
inline void Message::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Message::id() const {
  // @@protoc_insertion_point(field_get:netdesign2.Message.id)
  return id_;
}
inline void Message::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:netdesign2.Message.id)
}

// int32 timestamp = 3;
inline void Message::clear_timestamp() {
  timestamp_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Message::timestamp() const {
  // @@protoc_insertion_point(field_get:netdesign2.Message.timestamp)
  return timestamp_;
}
inline void Message::set_timestamp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:netdesign2.Message.timestamp)
}

// int32 internalId = 4;
inline void Message::clear_internalid() {
  internalid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Message::internalid() const {
  // @@protoc_insertion_point(field_get:netdesign2.Message.internalId)
  return internalid_;
}
inline void Message::set_internalid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  internalid_ = value;
  // @@protoc_insertion_point(field_set:netdesign2.Message.internalId)
}

// -------------------------------------------------------------------

// ContactMessageRequest

// string token = 1;
inline void ContactMessageRequest::clear_token() {
  token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ContactMessageRequest::token() const {
  // @@protoc_insertion_point(field_get:netdesign2.ContactMessageRequest.token)
  return token_.GetNoArena();
}
inline void ContactMessageRequest::set_token(const std::string& value) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netdesign2.ContactMessageRequest.token)
}
inline void ContactMessageRequest::set_token(std::string&& value) {
  
  token_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netdesign2.ContactMessageRequest.token)
}
inline void ContactMessageRequest::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netdesign2.ContactMessageRequest.token)
}
inline void ContactMessageRequest::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netdesign2.ContactMessageRequest.token)
}
inline std::string* ContactMessageRequest::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:netdesign2.ContactMessageRequest.token)
  return token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ContactMessageRequest::release_token() {
  // @@protoc_insertion_point(field_release:netdesign2.ContactMessageRequest.token)
  
  return token_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ContactMessageRequest::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:netdesign2.ContactMessageRequest.token)
}

// int32 id = 2;
inline void ContactMessageRequest::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ContactMessageRequest::id() const {
  // @@protoc_insertion_point(field_get:netdesign2.ContactMessageRequest.id)
  return id_;
}
inline void ContactMessageRequest::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:netdesign2.ContactMessageRequest.id)
}

// int32 internalId = 3;
inline void ContactMessageRequest::clear_internalid() {
  internalid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ContactMessageRequest::internalid() const {
  // @@protoc_insertion_point(field_get:netdesign2.ContactMessageRequest.internalId)
  return internalid_;
}
inline void ContactMessageRequest::set_internalid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  internalid_ = value;
  // @@protoc_insertion_point(field_set:netdesign2.ContactMessageRequest.internalId)
}

// -------------------------------------------------------------------

// ContactMessageResponse

// .netdesign2.Message message = 1;
inline bool ContactMessageResponse::has_message() const {
  return this != internal_default_instance() && message_ != nullptr;
}
inline void ContactMessageResponse::clear_message() {
  if (GetArenaNoVirtual() == nullptr && message_ != nullptr) {
    delete message_;
  }
  message_ = nullptr;
}
inline const ::netdesign2::Message& ContactMessageResponse::message() const {
  const ::netdesign2::Message* p = message_;
  // @@protoc_insertion_point(field_get:netdesign2.ContactMessageResponse.message)
  return p != nullptr ? *p : *reinterpret_cast<const ::netdesign2::Message*>(
      &::netdesign2::_Message_default_instance_);
}
inline ::netdesign2::Message* ContactMessageResponse::release_message() {
  // @@protoc_insertion_point(field_release:netdesign2.ContactMessageResponse.message)
  
  ::netdesign2::Message* temp = message_;
  message_ = nullptr;
  return temp;
}
inline ::netdesign2::Message* ContactMessageResponse::mutable_message() {
  
  if (message_ == nullptr) {
    auto* p = CreateMaybeMessage<::netdesign2::Message>(GetArenaNoVirtual());
    message_ = p;
  }
  // @@protoc_insertion_point(field_mutable:netdesign2.ContactMessageResponse.message)
  return message_;
}
inline void ContactMessageResponse::set_allocated_message(::netdesign2::Message* message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete message_;
  }
  if (message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    
  } else {
    
  }
  message_ = message;
  // @@protoc_insertion_point(field_set_allocated:netdesign2.ContactMessageResponse.message)
}

// -------------------------------------------------------------------

// FriendSendMessageRequest

// .netdesign2.RawMessage message = 1;
inline bool FriendSendMessageRequest::has_message() const {
  return this != internal_default_instance() && message_ != nullptr;
}
inline void FriendSendMessageRequest::clear_message() {
  if (GetArenaNoVirtual() == nullptr && message_ != nullptr) {
    delete message_;
  }
  message_ = nullptr;
}
inline const ::netdesign2::RawMessage& FriendSendMessageRequest::message() const {
  const ::netdesign2::RawMessage* p = message_;
  // @@protoc_insertion_point(field_get:netdesign2.FriendSendMessageRequest.message)
  return p != nullptr ? *p : *reinterpret_cast<const ::netdesign2::RawMessage*>(
      &::netdesign2::_RawMessage_default_instance_);
}
inline ::netdesign2::RawMessage* FriendSendMessageRequest::release_message() {
  // @@protoc_insertion_point(field_release:netdesign2.FriendSendMessageRequest.message)
  
  ::netdesign2::RawMessage* temp = message_;
  message_ = nullptr;
  return temp;
}
inline ::netdesign2::RawMessage* FriendSendMessageRequest::mutable_message() {
  
  if (message_ == nullptr) {
    auto* p = CreateMaybeMessage<::netdesign2::RawMessage>(GetArenaNoVirtual());
    message_ = p;
  }
  // @@protoc_insertion_point(field_mutable:netdesign2.FriendSendMessageRequest.message)
  return message_;
}
inline void FriendSendMessageRequest::set_allocated_message(::netdesign2::RawMessage* message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete message_;
  }
  if (message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    
  } else {
    
  }
  message_ = message;
  // @@protoc_insertion_point(field_set_allocated:netdesign2.FriendSendMessageRequest.message)
}

// -------------------------------------------------------------------

// FriendSendMessageResponse

// .netdesign2.Message message = 1;
inline bool FriendSendMessageResponse::has_message() const {
  return this != internal_default_instance() && message_ != nullptr;
}
inline void FriendSendMessageResponse::clear_message() {
  if (GetArenaNoVirtual() == nullptr && message_ != nullptr) {
    delete message_;
  }
  message_ = nullptr;
}
inline const ::netdesign2::Message& FriendSendMessageResponse::message() const {
  const ::netdesign2::Message* p = message_;
  // @@protoc_insertion_point(field_get:netdesign2.FriendSendMessageResponse.message)
  return p != nullptr ? *p : *reinterpret_cast<const ::netdesign2::Message*>(
      &::netdesign2::_Message_default_instance_);
}
inline ::netdesign2::Message* FriendSendMessageResponse::release_message() {
  // @@protoc_insertion_point(field_release:netdesign2.FriendSendMessageResponse.message)
  
  ::netdesign2::Message* temp = message_;
  message_ = nullptr;
  return temp;
}
inline ::netdesign2::Message* FriendSendMessageResponse::mutable_message() {
  
  if (message_ == nullptr) {
    auto* p = CreateMaybeMessage<::netdesign2::Message>(GetArenaNoVirtual());
    message_ = p;
  }
  // @@protoc_insertion_point(field_mutable:netdesign2.FriendSendMessageResponse.message)
  return message_;
}
inline void FriendSendMessageResponse::set_allocated_message(::netdesign2::Message* message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete message_;
  }
  if (message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    
  } else {
    
  }
  message_ = message;
  // @@protoc_insertion_point(field_set_allocated:netdesign2.FriendSendMessageResponse.message)
}

// -------------------------------------------------------------------

// SetupChannelRequest

// string token = 1;
inline void SetupChannelRequest::clear_token() {
  token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SetupChannelRequest::token() const {
  // @@protoc_insertion_point(field_get:netdesign2.SetupChannelRequest.token)
  return token_.GetNoArena();
}
inline void SetupChannelRequest::set_token(const std::string& value) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netdesign2.SetupChannelRequest.token)
}
inline void SetupChannelRequest::set_token(std::string&& value) {
  
  token_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netdesign2.SetupChannelRequest.token)
}
inline void SetupChannelRequest::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netdesign2.SetupChannelRequest.token)
}
inline void SetupChannelRequest::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netdesign2.SetupChannelRequest.token)
}
inline std::string* SetupChannelRequest::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:netdesign2.SetupChannelRequest.token)
  return token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SetupChannelRequest::release_token() {
  // @@protoc_insertion_point(field_release:netdesign2.SetupChannelRequest.token)
  
  return token_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SetupChannelRequest::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:netdesign2.SetupChannelRequest.token)
}

// -------------------------------------------------------------------

// ChannelHeartRequest

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace netdesign2

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::netdesign2::Contact_ContactType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::netdesign2::Contact_ContactType>() {
  return ::netdesign2::Contact_ContactType_descriptor();
}
template <> struct is_proto_enum< ::netdesign2::MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::netdesign2::MessageType>() {
  return ::netdesign2::MessageType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_messages_2eproto
